{"version":3,"sources":["logo.svg","serviceWorker.js","usePushNotifications.js","App.js","index.js"],"names":["module","exports","console","log","isLocalhost","Boolean","window","location","hostname","match","pushServerPublicKey","register","config","navigator","URL","process","href","origin","addEventListener","swUrl","fetch","headers","then","response","contentType","get","status","indexOf","serviceWorker","ready","registration","unregister","reload","registerValidSW","catch","checkValidServiceWorker","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","error","a","Notification","requestPermission","pushManager","subscribe","userVisibleOnly","applicationServerKey","setInterval","showNotification","body","icon","message","pushNotificationSupported","usePushNotifications","useState","permission","userConsent","setSuserConsent","userSubscription","setUserSubscription","pushServerSubscriptionId","setPushServerSubscriptionId","setError","loading","setLoading","useEffect","getSubscription","pushSubscription","existingSubscription","getExixtingSubscription","onClickAskUserPermission","consent","name","code","onClickSusbribeToPushNotification","subscrition","err","onClickSendSubscriptionToPushServer","axios","post","data","id","onClickSendNotification","App","Loading","className","Error","isConsentGranted","src","logo","alt","disabled","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ff163a5d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconsole.log('[TestServiceWorker] run serviceWorker.js');\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\nconst pushServerPublicKey =\r\n  'BIN2Jc5Vmkmy-S3AUrcMlpKxJpLeVRAfu9WBqUbJ70SJOCWGCGXKY-Xzyh7HDr6KbRDGYHjqZ06OcS3BjD7uAm8';\r\n\r\nexport function register(config) {\r\n  console.log('[TestServiceWorker] register');\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      console.log('[TestServiceWorker] window.addEventListener load');\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n        console.log('aaa');\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n\r\nexport async function askUserPermission() {\r\n  return await Notification.requestPermission();\r\n}\r\n\r\nexport async function createNotificationSubscription() {\r\n  //wait for service worker installation to be ready\r\n\r\n  const serviceWorker = await navigator.serviceWorker.ready;\r\n\r\n  // subscribe and return the subscription\r\n  return await serviceWorker.pushManager.subscribe({\r\n    userVisibleOnly: true,\r\n    applicationServerKey: pushServerPublicKey\r\n  });\r\n}\r\n\r\nexport function getUserSubscription() {\r\n  //wait for service worker installation to be ready, and then\r\n  return navigator.serviceWorker.ready\r\n    .then(function(serviceWorker) {\r\n      return serviceWorker.pushManager.getSubscription();\r\n    })\r\n    .then(function(pushSubscription) {\r\n      return pushSubscription;\r\n    });\r\n}\r\n\r\nexport function isPushNotificationSupported() {\r\n  return 'serviceWorker' in navigator && 'PushManager' in window;\r\n}\r\n\r\n// Tự động hiển thị thông báo mỗi 10 phút\r\nsetInterval(function () {\r\n  console.log('[TestServiceWorker] setInterval 10s');\r\n\r\n  navigator.serviceWorker.ready\r\n  .then((registration) => {\r\n    registration.showNotification('Test New Message', {\r\n      body: \"test body\",\r\n      icon: '/logo.png'\r\n    });\r\n  })\r\n  .catch((error) => {\r\n    console.error(error.message);\r\n    console.error('[TestServiceWorker] navigator.serviceWorker.ready error', error.message);\r\n  });\r\n\r\n}, 10 * 1000);","import { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport * as serviceWorker from './serviceWorker';\n\nconst pushNotificationSupported = serviceWorker.isPushNotificationSupported();\n// check push notifications are supported by the browser\n\nexport default function usePushNotifications() {\n  const [userConsent, setSuserConsent] = useState(Notification.permission);\n  //to manage the user consent: Notification.permission is a JavaScript native function that return the current state of the permission\n  //We initialize the userConsent with that value\n  const [userSubscription, setUserSubscription] = useState(null);\n  //to manage the use push notification subscription\n  const [pushServerSubscriptionId, setPushServerSubscriptionId] = useState();\n  //to manage the push server subscription\n  const [error, setError] = useState(null);\n  //to manage errors\n  const [loading, setLoading] = useState(true);\n  //to manage async actions\n\n  useEffect(() => {\n    if (pushNotificationSupported) {\n      setLoading(true);\n      setError(false);\n      serviceWorker.register();\n    }\n  }, []);\n  //if the push notifications are supported, registers the service worker\n  //this effect runs only the first render\n\n  useEffect(() => {\n    setLoading(true);\n    setError(false);\n    const getExixtingSubscription = async () => {\n      const existingSubscription = await serviceWorker.getUserSubscription();\n      setUserSubscription(existingSubscription);\n      setLoading(false);\n    };\n    getExixtingSubscription();\n  }, []);\n  //Retrieve if there is any push notification subscription for the registered service worker\n  // this use effect runs only in the first render\n\n  /**\n   * define a click handler that asks the user permission,\n   * it uses the setSuserConsent state, to set the consent of the user\n   * If the user denies the consent, an error is created with the setError hook\n   */\n  const onClickAskUserPermission = () => {\n    setLoading(true);\n    setError(false);\n    serviceWorker.askUserPermission().then((consent) => {\n      setSuserConsent(consent);\n      if (consent !== 'granted') {\n        setError({\n          name: 'Consent denied',\n          message: 'You denied the consent to receive notifications',\n          code: 0\n        });\n      }\n      setLoading(false);\n    });\n  };\n  //\n\n  /**\n   * define a click handler that creates a push notification subscription.\n   * Once the subscription is created, it uses the setUserSubscription hook\n   */\n  const onClickSusbribeToPushNotification = () => {\n    setLoading(true);\n    setError(false);\n    serviceWorker\n      .createNotificationSubscription()\n      .then(function(subscrition) {\n        setUserSubscription(subscrition);\n        setLoading(false);\n      })\n      .catch((err) => {\n        console.error(\n          \"Couldn't create the notification subscription\",\n          err,\n          'name:',\n          err.name,\n          'message:',\n          err.message,\n          'code:',\n          err.code\n        );\n        setError(err);\n        setLoading(false);\n      });\n  };\n\n  /**\n   * define a click handler that sends the push susbcribtion to the push server.\n   * Once the subscription ics created on the server, it saves the id using the hook setPushServerSubscriptionId\n   */\n  const onClickSendSubscriptionToPushServer = () => {\n    setLoading(true);\n    setError(false);\n    axios\n      .post('http://localhost:4000/subscription', { data: userSubscription })\n      .then(function(response) {\n        setPushServerSubscriptionId(response.data.id);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(err);\n      });\n  };\n\n  /**\n   * define a click handler that requests the push server to send a notification, passing the id of the saved subscription\n   */\n  const onClickSendNotification = async () => {\n    setLoading(true);\n    setError(false);\n    axios.get(`http://localhost:4000/subscription/${pushServerSubscriptionId}`).catch((error) => {\n      setLoading(false);\n      setError(error);\n    });\n    setLoading(false);\n  };\n\n  return {\n    onClickAskUserPermission,\n    onClickSusbribeToPushNotification,\n    onClickSendSubscriptionToPushServer,\n    pushServerSubscriptionId,\n    onClickSendNotification,\n    userConsent,\n    pushNotificationSupported,\n    userSubscription,\n    error,\n    loading\n  };\n}\n","import React from 'react';\nimport logo from './logo.svg';\nimport usePushNotifications from './usePushNotifications';\nimport './App.css';\n\nfunction App() {\n  const {\n    userConsent,\n    pushNotificationSupported,\n    userSubscription,\n    onClickAskUserPermission,\n    onClickSusbribeToPushNotification,\n    onClickSendSubscriptionToPushServer,\n    pushServerSubscriptionId,\n    onClickSendNotification,\n    error,\n    loading\n  } = usePushNotifications();\n\n  const Loading = ({ loading }) =>\n    loading ? <div className='app-loader'>Please wait, we are loading something...</div> : null;\n  const Error = ({ error }) =>\n    error ? (\n      <section className='app-error'>\n        <h2>{error.name}</h2>\n        <p>Error message : {error.message}</p>\n        <p>Error code : {error.code}</p>\n      </section>\n    ) : null;\n\n  const isConsentGranted = userConsent === 'granted';\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <img src={logo} className='App-logo' alt='logo' />\n        <Loading loading={loading} />\n\n        <p>Push notification are {!pushNotificationSupported && 'NOT'} supported by your device.</p>\n\n        <p>\n          User consent to recevie push notificaitons is <strong>{userConsent}</strong>.\n        </p>\n\n        <Error error={error} />\n\n        <button\n          disabled={!pushNotificationSupported || isConsentGranted}\n          onClick={onClickAskUserPermission}>\n          {isConsentGranted ? 'Consent granted' : ' Ask user permission'}\n        </button>\n\n        <button\n          disabled={!pushNotificationSupported || !isConsentGranted || userSubscription}\n          onClick={onClickSusbribeToPushNotification}>\n          {userSubscription ? 'Push subscription created' : 'Create Notification subscription'}\n        </button>\n\n        <button\n          disabled={!userSubscription || pushServerSubscriptionId}\n          onClick={onClickSendSubscriptionToPushServer}>\n          {pushServerSubscriptionId\n            ? 'Subscrption sent to the server'\n            : 'Send subscription to push server'}\n        </button>\n\n        {pushServerSubscriptionId && (\n          <div>\n            <p>The server accepted the push subscrption!</p>\n            <button onClick={onClickSendNotification}>Send a notification</button>\n          </div>\n        )}\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}